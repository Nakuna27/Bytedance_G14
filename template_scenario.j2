import requests
import json
import pytest
import time
import uuid
import random
from faker import Faker
fake = Faker("zh_CN")

# --- å…¨å±€é…ç½®: å¯å®¹å¿çš„é”™è¯¯ç  ---
IGNORED_ERROR_CODES = [
    401, 403, 429, 230027, 230003, 99991663,
    "PERMISSION_DENIED", "ACCESS_LIMIT_REACHED", 2005005
]

{% for scenario in scenarios %}
def {{ scenario.scenario_name }}():
    """ {{ scenario.description }} """
    print(f"\nðŸš€ æ‰§è¡Œ: {{ scenario.description }}")
    vars_pool = {}
    temp_uuid = None
    no_proxy = {"http": None, "https": None}

    {% for step in scenario.steps %}
    print(f"  ðŸ‘‰ Step: {{ step.method }} - {{ step.url }}")

    url = "{{ step.url }}"
    headers = {{ step.headers }}
    body = {{ step.body }}
    params = {{ step.params }}

    def smart_inject(d):
        nonlocal temp_uuid
        if isinstance(d, dict):
            for k, v in d.items():
                if isinstance(v, dict): smart_inject(v)
                elif isinstance(v, list):
                    for item in v: smart_inject(item)

                # --- 1. å˜å¼‚æ ‡è®° ---
                elif v == "__OVERFLOW__": d[k] = "A" * 2048
                elif v == "__WRONG_TYPE__": d[k] = 123456
                elif v == "GENERATE_UUID":
                    temp_uuid = str(uuid.uuid4())
                    d[k] = temp_uuid
                    print(f"     ðŸ§© ç”ŸæˆUUID: {temp_uuid}")
                elif v == "reuse_uuid_from_step_1":
                    d[k] = temp_uuid
                    print(f"     ðŸ§© å¤ç”¨UUID: {temp_uuid}")

                # --- 2. é€šç”¨æ¨¡ç³ŠåŒ¹é… ---
                elif isinstance(v, str) and ("raw_data" in v or "Auto_" in v):
                    key_lower = k.lower()
                    if "email" in key_lower: d[k] = fake.email()
                    elif "phone" in key_lower or "mobile" in key_lower: d[k] = f"+8613{fake.numerify('#########')}"
                    elif "url" in key_lower or "link" in key_lower: d[k] = fake.url()
                    elif "ip" in key_lower: d[k] = fake.ipv4()
                    elif "name" in key_lower or "title" in key_lower:
                        d[k] = f"Auto_{fake.word()}_{random.randint(1,999)}"
                    elif "id" in key_lower and "user" in key_lower: d[k] = "ou_generic_user_id"

                    elif "content" in key_lower or "json" in key_lower or "config" in key_lower:
                        try:
                            d[k] = json.dumps({"text": f"Auto_Content_{int(time.time())}"})
                        except:
                            d[k] = f"Auto_{k}_{int(time.time())}"
                    elif "priority" in key_lower:
                         d[k] = random.randint(2, 100)
                    else:
                        d[k] = f"Auto_{k}_{int(time.time())}"
        return d

    body = smart_inject(body)

    for k, v in vars_pool.items():
        if f"${k}" in url:
            url = url.replace(f"${k}", str(v))
            print(f"     ðŸ”„ æ›¿æ¢URL: ${k} -> {v}")

    for k, v in body.items():
        if isinstance(v, list):
            final_list = []
            for item in v:
                if isinstance(item, str) and item.startswith("$") and item[1:] in vars_pool:
                    final_list.append(vars_pool[item[1:]])
                    print(f"     ðŸ”„ åˆ—è¡¨æ³¨å…¥: {item} -> {vars_pool[item[1:]]}")
                else: final_list.append(item)
            body[k] = final_list

    try:
        response = None
        # ðŸ§  æ™ºèƒ½å¤§è„‘ 1: æœ€ç»ˆä¸€è‡´æ€§è½®è¯¢
        {% if step.method == 'GET' %}
        max_retries = 3
        for attempt in range(max_retries):
            response = requests.request("GET", url=url, headers=headers, json=body, params=params, proxies=no_proxy)
            if response.status_code == 404 and attempt < max_retries - 1:
                print(f"     â³ æ•°æ®å¯èƒ½å°šæœªåŒæ­¥ï¼Œç­‰å¾… 1s åŽé‡è¯• ({attempt+1}/{max_retries})...")
                time.sleep(1)
                continue
            else:
                break
        {% else %}
        response = requests.request("{{ step.method }}", url=url, headers=headers, json=body, params=params, proxies=no_proxy)
        {% endif %}

        print(f"     ðŸ“¡ çŠ¶æ€: {response.status_code}")

        # ðŸŒŸ æ™ºèƒ½æ–­è¨€é€»è¾‘
        is_expected_fail = "âŒ" in "{{ step.description }}" or "âŒ" in "{{ scenario.description }}" or "iso" in "{{ scenario.scenario_name }}"

        if is_expected_fail:
             if response.status_code in [200, 201, 204]:
                 print(f"     âš ï¸ è­¦å‘Š: é€†å‘ç”¨ä¾‹è¿”å›žäº†æˆåŠŸ (å¯èƒ½æ ¡éªŒå®½æ¾)")
             else:
                 print(f"     âœ… ç¬¦åˆé¢„æœŸ: è¯·æ±‚è¢«æ‹’ç» (Code {response.status_code})")
        else:
             if response.status_code not in [200, 201, 204]:
                 try:
                     err_data = response.json()
                     err_code = err_data.get("code") or err_data.get("status") or response.status_code
                     err_msg = err_data.get("msg") or response.text
                     if err_code in IGNORED_ERROR_CODES:
                         print(f"     âš ï¸ è­¦å‘Š: çŽ¯å¢ƒ/æƒé™é™åˆ¶ (Code {err_code}) - {err_msg}")
                     else:
                         print(f"âŒ å¤±è´¥: {response.text}")
                         assert response.status_code in [200, 201, 204]
                 except:
                     print(f"âŒ å¤±è´¥ (éžJSONå“åº”): {response.text}")
                     assert response.status_code in [200, 201, 204]
             else:
                 assert response.status_code in [200, 201, 204]

                 # ðŸ§  æ™ºèƒ½å¤§è„‘ 3: æ·±åº¦æ•°æ®ä¸€è‡´æ€§æ ¡éªŒ
                 {% if step.method in ['PUT', 'POST'] and step.body %}
                 try:
                     resp_json = response.json()
                     if isinstance(resp_json, dict) and ("data" in resp_json or "body" in resp_json):
                         resp_data = resp_json.get("data") or resp_json.get("body") or resp_json
                         req_body = body
                         for k, v in req_body.items():
                             if k in resp_data and isinstance(v, (str, int)) and "Auto_" not in str(v) and "__" not in str(v):
                                 if str(resp_data[k]) != str(v):
                                     print(f"     âš ï¸ æ•°æ®ä¸€è‡´æ€§é£Žé™©: è¯·æ±‚ {k}={v}, å“åº”={resp_data[k]}")
                                 else:
                                     print(f"     âœ… æ•°æ®éªŒè¯é€šè¿‡: {k}={v}")
                 except: pass
                 {% endif %}

                 {% if step.extract %}
                 try:
                     extracts = {{ step.extract }}
                     for var, path in extracts.items():
                         val = response.json()
                         for p in path.split('.'): val = val.get(p, {})
                         if isinstance(val, (str, int)) and val:
                             vars_pool[var] = val
                             print(f"     âœ… æå–æˆåŠŸ: ${var} = {val}")
                 except: pass
                 {% endif %}
    except Exception as e:
        print(f"âŒ å¼‚å¸¸: {e}"); raise e
    {% endfor %}
    print("âœ… é€šè¿‡")
{% endfor %}